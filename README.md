# Leetcode1
## 贪心算法
### 10.Container With Most Water
储存最大容量的水要用到贪心算法即从最长的宽（用双指针的技巧由两头向中间逼近）开始进行选择，面积是宽×高，一直取最大面积，然后比较双边的高度（左边矮：i++；反之：j--；），最后当j>i就可以求出最大的面积。这题用贪心算法的妙处就是可以一直取最好的选择，舍弃不好的选项，然后求出目标值。
### 122.Best Time to Buy and Sell Stack
求最好的时间买和卖股票很符合贪心算法的性质。我是重新构造了一个数组即：将后一天的价值减去前一天的价值，这样求出的数有正有负。然后用贪心算法不停地取正值相加，舍弃负值和0，最后求出最大利润
，如果没有正值，则返回0.运行时间为O（n）。
### 135.Candy
每个孩子都很贪心，都不允许比自己分低的人拿到比自己多的糖果，每人最少都要有一个糖果，最后还要让糖果总量最小。所以我选择了用两次遍历的方法，一次从前向后，一次从后向前。第一次是要和前面一位的孩子比，如果分比他高，糖果就加一。第二次是要修正因为第一次遍历所造成的错误，就是后面的孩子分低却拿了比前面一位孩子多的糖果，就要让前面一位孩子拿到比后面一位孩子多一个的糖果。
### 406.Queue Reconstruction by Height
按身高排序的另类问题，这题要求在前面并且比自己高的人要符合序号。所以我对二维数组进行了排序，第一关键字是身高按降序排，第二关键字是序号按升序排，然后依次插入进新数组。排序的目的是为了在插入过程中新插入的元素不会改变前面插入元素的序号，所以我们可以只考虑将新元素放在最优的位置，从局部最优完全可以推出全体最优，于是数组重新排序完成。
## 双指针算法
### 26. Remove Duplicates from Sorted Array
删除重复的元素，并在数组结尾用0补齐删除所空出的空间。这题可能要三个指针，i指向numsSize-1，j指向numsSize-2，pos指针指向numsSize-1.for语句令i，j指针向下遍历，遇到相同的两个元素，删除掉后一个元素，然后将后面的元素都向前提一格，最后将pos指针所指的元素赋值为0，然后pos--。
### 88. Merge Sorted Array
合并两个排好序的数组，一个合并两个排好序的数组到较长的那个数组中（删除长数组比短数组多的元素再合并）。要用到三个指针，两个指针来遍历，一个指针来赋值。和上题类似。
## 排序算法
### 215.数组中的第k个最大元素
快速选择的直接使用，主要是是用来练习快速选择的熟练度。
### 75. Sort Colors
可以使用快速排序，先选择2作为枢纽元，再选择1作为枢纽元。
### 169. Majority Element
进行排序，最后取中间值（一定是最多的元素）。
### 217. Contains Duplicate
寻找是否有重复元素，进行排序后，直接遍历数组查找是否前后有相同元素。
## 二分查找
### 33. Search in Rotated Sorted Array
这题用二分查找是最快的，因为在分半查找之后一定会出现有一半的数组是递增排序的，然后在这一半有序数组中就很容易查找target，找不到就去另外一半去查找。
### 34. Find First and Last Position of Element in Sorted Array
二分查找可以最快地接近目标值，然后在目标值地左右查找与其相同地元素，再返回。
### 69. Sqrt(x)
先设mid=(0+x)/2,sprt=x/mid,如果sqrt=mid,则算术平方根就是mid,如果sqrt>mid在上半个数组中继续查找，否则在下半个数组中继续查找。由于算术平方根通常小于x/2，我就直接在（0，x/2）中查找。
### 81. Search in Rotated Sorted Array II
33题的类似题，程序几乎是相同的，但是多了一步：遇到头尾元素相同无法判断是否哪半个数组是递增数组时，进行i++操作。
## 回溯算法
在回溯算法之后我改用Java语言进行编程。
### 39. Combination Sum
这道题是很典型的回溯算法，先在数组中遍历元素，一步步地减，直到target=0时，才输出合适的元素数组，当发现target<0时，要删除掉挑选出来的数组中的最后一个元素。
### 46. Permutations
排列和组合不同，可以允许相同元素以不同顺序进行排列，所以使用Collections.swap进行交换就行了。其余步骤和39题没有差别。
### 77. Combinations
组合问题，和39题不一样的是回溯之后会多出一部分元素，要进行删除。
### 216. Combination Sum III
组合总和问题，并且要求不包含重复元素的组合。多了一步回溯之后要将pos指针再往前指一步，就一定不会有重复元素的组合了。
## 深度优先搜索
### 94. Binary Tree Inorder Traversal
二叉树的中序遍历。
### 200. Number of Islands
岛屿数量，1是陆地，0是海洋，相连的是岛屿。用二维数组表示，从左向右，从上到下遍历，先找到1，再用递归去寻找1的上下左右，直到都是0（海洋），则岛屿数量加一，再接着寻找。
### 695. Max Area of Island
和200题一样的类型（即在二维数组中进行深度搜索）。多了一步对岛屿面积的计算，只要用area进行记录，再用if语句比较得出最大面积。
## 哈希表
哈希表有两种类型的题。1.哈希表结构的直接应用进行查找。2.哈希映射的一对一查找。
### 1.两数之和
用哈希表对目标数-一个数进行查找，即（target-nums[i])。实现了更快时间进行。
### 3.无重复字符的最长子串
哈希表查重。
### 13.罗马数字转整数
用哈希映射将罗马数字与整数一一对应，就可实现对数字的表示。
### 128.最长连续序列
这题可以很巧妙的应用哈希表的查重作用，首先对连续序列中的最小元素进行查找，因为只有从最小的开始才可能是最长的。然后对数组遍历就可实现。由于哈希表的所有操作都是O（1）。所以整个程序就只有O（n）的运行时间。
### 169.多数元素
用哈希表的查重性质可以很快搞定。
### 217.存在重复元素
用哈希表的查重性质可以解决。
### 219.存在重复元素二
用哈希表的查重性质可以解决。
### 268.丢失的数字
哈希表有着查找的作用，可以比一般的查找程序更快的实现程序。
## 动态规划
动态规划的作用就是解决递归问题中运行时间爆炸的，用空间来换取时间的思想。通常会寻找一个最优子结构对所有的情况进行筛选，最后通过比较得出最优解。（所以在动态规划中推出最优方程就可以解决）。
### 64.最小路径和
对最优路径的选择即：对于向下还是向左的选择问题。所以最优方程就是对向下和向左的最小步数。边界情况就是最右和最下，只会右一种情况。
### 70.爬楼梯
统计所有的爬楼梯方法，最优方程就是f(x)=f(x-1)+f(x-2)。即最后一步是1还是2的可能性相加。
### 198.打家劫舍
不能盗窃邻居，所以最优方程就是偷了之后的钱和之前一次没偷的最大值，就是比较舍弃的钱的值来进行选择。
### 221.最大正方形
用一个大小相同的矩阵来记录边长，取值是左边，上边，左上元素的最小值加1，边界情况可以将其都赋值为原矩阵对应的值。
### 279.完全平方数
用的是和算法导论例题钢条切割一样的方法，即减去一个完全平方数，再看看剩下的值怎样切割最快。
### 542.01矩阵
用一个大小相同的矩阵来记录和0的距离，将原来矩阵为0的位置都赋值为0.再一步步计算每个1和0的距离。最后输出矩阵。









，
